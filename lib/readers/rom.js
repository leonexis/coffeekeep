// Generated by CoffeeScript 1.6.3
(function() {
  var ROMReader, fs, readers, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  readers = require('./');

  fs = require('fs');

  exports.ROMReader = ROMReader = (function(_super) {
    __extends(ROMReader, _super);

    function ROMReader() {
      _ref = ROMReader.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ROMReader.prototype.debug = false;

    ROMReader.prototype.ROM_DIRECTIONS = ['north', 'east', 'south', 'west', 'up', 'down'];

    ROMReader.prototype.getString = function() {
      var data;
      data = this.getLine();
      while ((data != null) && data.indexOf("~") === -1) {
        data += '\n' + this.getLine();
      }
      data = data.split('~')[0];
      if (this.debug) {
        console.log("Got string " + data);
      }
      return data;
    };

    ROMReader.prototype.getLine = function() {
      var _ref1;
      _ref1 = this.lines, this.line = _ref1[0], this.lines = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
      this.lineIndex += 1;
      if (this.line == null) {
        throw new Error("End of file");
      }
      return this.line;
    };

    ROMReader.prototype.getList = function() {
      return this.getLine().split(' ');
    };

    ROMReader.prototype.strToList = function(text) {
      text = text.replace(/\s{2,}/g, ' ');
      return text.split(' ');
    };

    ROMReader.prototype.read = function(filename) {
      var current, data, direction, emitState, extra, index, levels, link, state, subsec, title, _ref1, _ref2, _ref3, _ref4;
      data = fs.readFileSync(filename, {
        encoding: 'ascii'
      });
      state = null;
      current = null;
      index = 0;
      this.lineIndex = 0;
      this.lines = data.split('\n');
      this.linesTotal = this.lines.length;
      while (this.lines.length > 0) {
        this.getLine();
        if (!this.line || this.line.indexOf("#") !== 0) {
          continue;
        }
        if (this.debug) {
          console.log("Found marker " + this.line);
        }
        index = Number(this.line.slice(1));
        if ((index == null) || Number.isNaN(index)) {
          state = this.line.slice(1).toLowerCase();
          if (this.debug) {
            console.log("Marker is a new section " + state + " (" + this.line + ")");
          }
          if (state === 'mobiles' || state === 'rooms' || state === 'objects') {
            continue;
          }
        } else {
          if (this.debug) {
            console.log("Marker is new index " + index);
          }
          if (index === 0) {
            if (this.debug) {
              console.log("End of section found, skipping");
            }
            continue;
          }
        }
        switch (state) {
          case 'area':
            current = {};
            current.id = this.getString();
            current.description = this.getString();
            title = this.getString();
            if ((title != null) && title.indexOf('{' === 0 && title.indexOf('}' > 0))) {
              _ref1 = title.split('}'), levels = _ref1[0], title = _ref1[1];
              levels = levels.slice(1).trim();
              _ref2 = this.strToList(levels), current.minLevel = _ref2[0], current.maxLevel = _ref2[1];
            }
            current.title = title;
            this.getList();
            break;
          case 'rooms':
            current = {};
            current.id = String(index);
            current.title = this.getString();
            current.description = this.getString();
            _ref3 = this.getList(), current.x_obsolete_area = _ref3[0], current.x_roomFlags = _ref3[1], current.x_sectorType = _ref3[2];
            current.links = {};
            current.extras = [];
            while ((subsec = this.getLine()) && subsec !== 'S') {
              switch (subsec[0]) {
                case 'D':
                  link = {};
                  direction = this.ROM_DIRECTIONS[Number(subsec.slice(1))];
                  link.description = this.getString();
                  link.keywords = this.getString();
                  _ref4 = this.getList(), link.x_locks = _ref4[0], link.x_key = _ref4[1], link.room = _ref4[2];
                  current.links[direction] = link;
                  break;
                case 'E':
                  extra = {};
                  extra.keywords = this.getString();
                  extra.description = this.getString();
                  current.extras.push(extra);
              }
            }
        }
        if ((state != null) && (current != null)) {
          emitState = (function() {
            switch (state) {
              case 'rooms':
                return 'room';
              default:
                return state;
            }
          })();
          if (this.debug) {
            console.log("Emitting " + emitState + ", " + (JSON.stringify(current)));
          }
          this.emit(emitState, current);
        }
        current = null;
      }
      return this.emit('done');
    };

    return ROMReader;

  })(readers.AreaReader);

  exports.ROMReader = ROMReader;

}).call(this);
